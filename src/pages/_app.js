
import React, { useEffect } from 'react'

import axios from "axios";
import Head from 'next/head'
import SuperTokensReact from 'supertokens-auth-react'
import * as SuperTokensConfig from '../../config/frontendConfig'
import Session from 'supertokens-auth-react/recipe/session'
import { redirectToAuth } from 'supertokens-auth-react/recipe/thirdpartyemailpassword'
import theme from '../assets/theme'
import { ThemeProvider } from "@mui/material/styles";
import CssBaseline from '@mui/material/CssBaseline'

import { useSelector, useDispatch } from 'react-redux'
import { wrapper } from '../app/store'
import { getAuth, getCart } from '../app/store/selectors'
import { authLoginAdmin, authLoginUser } from '../app/store/authSlice'
import { cartSet } from '../app/store/cartSlice'

import createEmotionCache from '../lib/createEmotionCache'
import { CacheProvider } from '@emotion/react';

// Del Swipper eslint-disable-next-line
//import "swiper/css/bundle";

import "../styles/globals.css"

Session.addAxiosInterceptors(axios);

//Material UI-Next.js
// Client-side cache, shared for the whole session of the user in the browser.
const clientSideEmotionCache = createEmotionCache();

//Supertokens logic
async function initNode() {
  const supertokensNode = await import('supertokens-node')
  const { backendConfig } = await import('../../config/backendConfig')
  supertokensNode.init(backendConfig())
}

if (typeof window !== 'undefined') {
  SuperTokensReact.init(SuperTokensConfig.frontendConfig())
} else {
  initNode().catch('ERROR INIT SUPERTOKENS _APP.JS', console.error)
}

function App({ Component, pageProps, emotionCache = clientSideEmotionCache }) {

  const { isLogged, isAdmin, authId } = useSelector(getAuth)

  const { cartProducts } = useSelector(getCart)
  //https://stackoverflow.com/questions/71400494/flash-of-unstyled-content-fouc-for-nextjs-using-mantine
  const dispatch = useDispatch()

  //Supertokens logic
  useEffect(() => {
    async function doRefresh() {
      if (pageProps.fromSupertokens === 'needs-refresh') {
        if (await Session.attemptRefreshingSession()) {
          location.reload()
        } else {
          // user has been logged out
          redirectToAuth()
        }
      }
    }
    doRefresh()
  }, [pageProps.fromSupertokens])

  useEffect(() => {
    const storedCart = JSON.parse(localStorage.getItem("cart"));
    storedCart && dispatch(cartSet(storedCart))
    const checkSession = async () => {
      //Si existe una sesiÃ³n activa, la promesa devuelve true
      // setIsLogged(await Session.doesSessionExist())
      if (await Session.doesSessionExist()) {
        /**
             * Si el userId del usuario logado tiene asignado el rol de administrador, admin=true
             * userdId es el identificador de usuario en la bdd de supertokens. Se obtiene y se renombra a authID
             * authId es un identificador de usuario en la bdd de la app. Permite relacionar el usuario logado
             * con supertokens con su perfil de usuario en la bdd de la app.
             */
        const { admin, userId: authId } = await Session.getAccessTokenPayloadSecurely()
        //const info = state && await Session.getAccessTokenPayloadSecurely()
        //const user = await getUser(authId)
        //Convierte el valor admin en booleano porque, cuando no es true, devuelve undefined
        // setIsLogged({ state, admin: !!admin, authId: authId ? authId : '', user: user })
        //setIsLogged({ state: true, admin: !!admin, authId: authId ? authId : '' })
        //console.log('@@@@@@@@@@@@@@@@@@@@@@@@', admin)

        !!admin ? dispatch(authLoginAdmin(authId)) : dispatch(authLoginUser(authId))
      }
    }
    checkSession()
  }, [])

  useEffect(() => {
    localStorage.setItem("cart", JSON.stringify(cartProducts))

  }, [cartProducts])

  if (pageProps.fromSupertokens === 'needs-refresh') {
    return null
  }
  useEffect(() => {
    document.documentElement.style.visibility = 'visible'
  }, [])
  //const { data: user, isFetching: isFetchingUser } = console.log('---_app.js') || useGetUserQuery(authId)

  return (
    <CacheProvider value={emotionCache}>
      <Head>
        <meta name="google-site-verification" content="zbvzA8Zrgps5RRh86gp797a6HsdJkBRhP5vY0K0KkjQ" />
        <title>Sevimatic</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <ThemeProvider theme={theme}>
        <CssBaseline />
        <Component  {...pageProps} />
      </ThemeProvider >
    </CacheProvider>
  )
}


export default wrapper.withRedux(App)

